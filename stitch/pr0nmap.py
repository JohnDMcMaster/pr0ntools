#!/usr/bin/python
'''
Generate a complete Google Map from input image(s)
'''

from pr0ntools.tile.tile import from_single
from pr0ntools.pimage import PImage
import argparse
import os
import os.path
import math

class Map:
	def __init__(self, image_in):
		self.image_in = image_in
		self.page_title = 'SiMap: %s' % image_in.split('.')[0]
		# Consider mangling this pased on the image name
		self.id = 'si_canvas'
		self.out_dir = 'map'
		self.max_level = None
		self.min_level = 0
		self.image = None
		
	def header(self):
		return '''	
<html>
<head>
<title>%s</title>
<script type="text/javascript" src="http://maps.google.com/maps/api/js?sensor=false"></script>
<style type="text/css">
  html { height: 100%% }
  body { height: 100%%; margin: 0; padding: 0 }
  #%s { height: 100%% }
</style>

</head>
<body>
''' % (self.page_title, self.id);

	def get_js(self):
		ret = ''
		ret += self.header()
		ret += self.div()
		ret += self.script()
		ret += self.footer()
		return ret

	def div(self):
		return '''
<div id="%s"></div>
''' % self.id;

	def script(self):
		ret = ''
		ret += self.script_header()
		ret += self.SiProjection_ctor()
		ret += self.fromLatLngToPoint()
		ret += self.fromPointToLatLng()
		ret += self.create_map()
		ret += self.script_footer()
		return ret
		
	def width(self):
		return self.image.width()
	def height(self):
		return self.image.height()
		
	def SI_MAX_ZOOM(self):
		return self.max_level
		
	def SI_RANGE_X(self):
		return self.width() / (2**self.SI_MAX_ZOOM())
	
	def SI_RANGE_Y(self):
		return self.height() / (2**self.SI_MAX_ZOOM())
	
	def script_header(self):
			return '''
<script>
//WARNING: this page is automatically generated
//Generated by pr0nmap
var options = {
  scrollwheel: false,
  scaleControl: true,
  mapTypeControlOptions: {style: google.maps.MapTypeControlStyle.DROPDOWN_MENU}
}
''';

	def SiProjection_ctor(self):
		return '''
function SiProjection() {
  // Using the base map tile, denote the lat/lon of the equatorial origin.
  this.worldOrigin_ = new google.maps.Point(%d / 2, %d / 2);

  // This projection has equidistant meridians, so each longitude
  // degree is a linear mapping.
  this.worldCoordinatePerLonDegree_ = %d / 360;
  this.worldCoordinatePerLatDegree_ = %d / 360;
};
''' % (self.SI_RANGE_X(), self.SI_RANGE_Y(), self.SI_RANGE_X(), self.SI_RANGE_Y());

	def fromLatLngToPoint(self):
		return '''
firstL = false
//firstL = true
SiProjection.prototype.fromLatLngToPoint = function(latLng) {
	var origin = this.worldOrigin_;
	var x = origin.x + this.worldCoordinatePerLonDegree_ * latLng.lng();
	var y = origin.y + this.worldCoordinatePerLatDegree_ * latLng.lat();
	if (firstL) {
		firstL = false;
		alert('(lng ' + latLng.lng() + ', lat ' + latLng.lat() + ') => (x ' + x + ', y ' + y + ')')
	}
	return new google.maps.Point(x, y);
};
''';

	def fromPointToLatLng(self):
		return '''
SiProjection.prototype.fromPointToLatLng = function(point, noWrap) {
  var y = point.y;
  var x = point.x;

  if (x < 0) {
    x = 0;
  }
  if (x >= %d) {
    x = %d;
  }
  if (y < 0) {
    y = 0;
  }
  if (y >= %d) {
    y = %d;
  }
  
if (firstL) {
	firstL = false;
	alert('(x ' + x + ', y ' + y + ') => (lng ' + latLng.lng() + ', lat ' + latLng.lat() + ')')
}

  var origin = this.worldOrigin_;
  var lng = (x - origin.x) / this.worldCoordinatePerLonDegree_;
  var lat = (y - origin.y) / this.worldCoordinatePerLatDegree_;
  return new google.maps.LatLng(lat, lng, noWrap);
};
''' % (self.SI_RANGE_X(), self.SI_RANGE_X(), self.SI_RANGE_Y(), self.SI_RANGE_Y());

	def create_map(self):
		return '''
var siMap = new google.maps.Map(document.getElementById("si_canvas"), options);
siMap.setCenter(new google.maps.LatLng(1, 1));
siMap.setZoom(%d);

first = false
//first = true;
var mos6522NoMetal = new google.maps.ImageMapType({
  getTileUrl: function(ll, z) {
  	//TODO: consider not 0 padding if this is going to be a performance issue
  	//it does make organizing them easier though
    var r = "tiles_out/" + z + "/y" + String("00" + ll.y).slice(-3) + "_x" + String("00" + ll.x).slice(-3) + ".jpg"; 
	if (first) {
	    first = false;
	    alert(r);
    }
    return r;
  },
  format:"jpg",
  tileSize: new google.maps.Size(256, 256),
  //isPng: true,
  maxZoom: %d,
  name: "SM",
  alt: "6522 w/o metal"
});
''' % (self.min_level, self.SI_MAX_ZOOM());

	def script_footer(self):
		return '''
mos6522NoMetal.projection = new SiProjection();


siMap.mapTypes.set('mos6522', mos6522NoMetal);
siMap.setMapTypeId('mos6522');

siMap.setOptions({
  mapTypeControlOptions: {
    mapTypeIds: [
      'mos6522'
    ],
    style: google.maps.MapTypeControlStyle.DROPDOWN_MENU
  }
});


</script>
''';

	def footer(self):
		return '''
</body>
</html>
''';

	def zoom_factor(self):
		return 2

	def gen_js(self):
		if os.path.exists(self.out_dir):
			os.system('rm -rf %s' % self.out_dir)
		os.mkdir(self.out_dir)

		self.image = PImage.from_file(self.image_in)
		if self.max_level is None:
			'''
			Calculate such that max level is a nice screen size
			Lets be generous for small viewers...especially considering limitations of mobile devices
			'''
			fit_width = 640
			fit_height = 480
			
			image = self.image
			width_levels = math.ceil(math.log(image.width(), self.zoom_factor()) - math.log(fit_width, self.zoom_factor()))
			height_levels = math.ceil(math.log(image.height(), self.zoom_factor()) - math.log(fit_height, self.zoom_factor()))
			self.max_level = int(max(width_levels, height_levels, 0))
			# Take the number of zoom levels required to fit the entire thing on screen
			print 'Calculated max zoom level for %d X %d screen to be %d (width max: %d, height max: %d)' % (fit_width, fit_height, self.max_level, width_levels, height_levels)
		js = self.get_js()
		js_filename = '%s/index.html' % self.out_dir
		open(js_filename, 'w').write(js)
		
		self.image = None

	def generate(self):
		'''
		It would be a good idea to check the tiles gnerated against what we are expecting
		'''
		# generate javascript
		self.gen_js()
		# Generate tiles
		print 'From single image in %s' % self.image_in
		from_single(self.image_in, self.max_level, self.min_level, out_dir_base='%s/tiles_out' % self.out_dir)
		
		
if __name__ == "__main__":
	parser = argparse.ArgumentParser(description='Generate Google Maps code from image file(s)')
	parser.add_argument('images_in', metavar='N', type=str, nargs='+', help='images in')
	parser.add_argument('--level-min', action="store", dest="level_min", type=int, default=0, help='Minimum zoom level')
	parser.add_argument('--level-max', action="store", dest="level_max", type=int, default=None, help='Maximum zoom level')
	parser.add_argument('--out', action="store", dest="out_dir", type=str, default="map", help='Output directory')
	args = parser.parse_args()
	
	if len(args.images_in) == 1:
		image_in = args.images_in[0]
		print 'Working on singe input image %s' % image_in
		m = Map(image_in)
		m.min_level = args.level_min
		m.max_level = args.level_max
		m.out_dir = args.out_dir
		m.generate()
	else:
		print 'bad number of images in %s' % len(args.images_in)
		sys.exit(1)
	

